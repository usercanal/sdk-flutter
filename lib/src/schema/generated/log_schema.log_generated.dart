// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable, constant_identifier_names

library schema.log;

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


import './common_schema.common_generated.dart' as schema_common;

///  Log severity levels (RFC 5424 syslog standard + TRACE)
enum LogLevel {
  EMERGENCY(0),
  ALERT(1),
  CRITICAL(2),
  ERROR(3),
  WARNING(4),
  NOTICE(5),
  INFO(6),
  DEBUG(7),
  TRACE(8);

  final int value;
  const LogLevel(this.value);

  factory LogLevel.fromValue(int value) {
    switch (value) {
      case 0: return LogLevel.EMERGENCY;
      case 1: return LogLevel.ALERT;
      case 2: return LogLevel.CRITICAL;
      case 3: return LogLevel.ERROR;
      case 4: return LogLevel.WARNING;
      case 5: return LogLevel.NOTICE;
      case 6: return LogLevel.INFO;
      case 7: return LogLevel.DEBUG;
      case 8: return LogLevel.TRACE;
      default: throw StateError('Invalid value $value for bit flag enum');
    }
  }

  static LogLevel? _createOrNull(int? value) =>
      value == null ? null : LogLevel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 8;
  static const fb.Reader<LogLevel> reader = _LogLevelReader();
}

class _LogLevelReader extends fb.Reader<LogLevel> {
  const _LogLevelReader();

  @override
  int get size => 1;

  @override
  LogLevel read(fb.BufferContext bc, int offset) =>
      LogLevel.fromValue(const fb.Uint8Reader().read(bc, offset));
}

///  Log-specific event types (optimized to uint8)
enum LogEventType {
  UNKNOWN(0),
  LOG(1),
  ENRICH(2);

  final int value;
  const LogEventType(this.value);

  factory LogEventType.fromValue(int value) {
    switch (value) {
      case 0: return LogEventType.UNKNOWN;
      case 1: return LogEventType.LOG;
      case 2: return LogEventType.ENRICH;
      default: throw StateError('Invalid value $value for bit flag enum');
    }
  }

  static LogEventType? _createOrNull(int? value) =>
      value == null ? null : LogEventType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static const fb.Reader<LogEventType> reader = _LogEventTypeReader();
}

class _LogEventTypeReader extends fb.Reader<LogEventType> {
  const _LogEventTypeReader();

  @override
  int get size => 1;

  @override
  LogEventType read(fb.BufferContext bc, int offset) =>
      LogEventType.fromValue(const fb.Uint8Reader().read(bc, offset));
}

///  Single log entry - field order preserved for compatibility
class LogEntry {
  LogEntry._(this._bc, this._bcOffset);
  factory LogEntry(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<LogEntry> reader = _LogEntryReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  LogEventType get eventType => LogEventType.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 4, 0));
  int get contextId => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 6, 0);
  LogLevel get level => LogLevel.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 8, 0));
  int get timestamp => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 10, 0);
  String? get source => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  String? get service => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 14);
  List<int>? get payload => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 16);

  @override
  String toString() {
    return 'LogEntry{eventType: ${eventType}, contextId: ${contextId}, level: ${level}, timestamp: ${timestamp}, source: ${source}, service: ${service}, payload: ${payload}}';
  }

  LogEntryT unpack() => LogEntryT(
      eventType: eventType,
      contextId: contextId,
      level: level,
      timestamp: timestamp,
      source: source,
      service: service,
      payload: const fb.Uint8ListReader(lazy: false).vTableGetNullable(_bc, _bcOffset, 16));

  static int pack(fb.Builder fbBuilder, LogEntryT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  Single log entry - field order preserved for compatibility
class LogEntryT implements fb.Packable {
  LogEventType eventType;
  int contextId;
  LogLevel level;
  int timestamp;
  String? source;
  String? service;
  List<int>? payload;

  LogEntryT({
      this.eventType = LogEventType.UNKNOWN,
      this.contextId = 0,
      this.level = LogLevel.EMERGENCY,
      this.timestamp = 0,
      this.source,
      this.service,
      this.payload});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? sourceOffset = source == null ? null
        : fbBuilder.writeString(source!);
    final int? serviceOffset = service == null ? null
        : fbBuilder.writeString(service!);
    final int? payloadOffset = payload == null ? null
        : fbBuilder.writeListUint8(payload!);
    fbBuilder.startTable(7);
    fbBuilder.addUint8(0, eventType.value);
    fbBuilder.addUint64(1, contextId);
    fbBuilder.addUint8(2, level.value);
    fbBuilder.addUint64(3, timestamp);
    fbBuilder.addOffset(4, sourceOffset);
    fbBuilder.addOffset(5, serviceOffset);
    fbBuilder.addOffset(6, payloadOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'LogEntryT{eventType: ${eventType}, contextId: ${contextId}, level: ${level}, timestamp: ${timestamp}, source: ${source}, service: ${service}, payload: ${payload}}';
  }
}

class _LogEntryReader extends fb.TableReader<LogEntry> {
  const _LogEntryReader();

  @override
  LogEntry createObject(fb.BufferContext bc, int offset) => 
    LogEntry._(bc, offset);
}

class LogEntryBuilder {
  LogEntryBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(7);
  }

  int addEventType(LogEventType? eventType) {
    fbBuilder.addUint8(0, eventType?.value);
    return fbBuilder.offset;
  }
  int addContextId(int? contextId) {
    fbBuilder.addUint64(1, contextId);
    return fbBuilder.offset;
  }
  int addLevel(LogLevel? level) {
    fbBuilder.addUint8(2, level?.value);
    return fbBuilder.offset;
  }
  int addTimestamp(int? timestamp) {
    fbBuilder.addUint64(3, timestamp);
    return fbBuilder.offset;
  }
  int addSourceOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addServiceOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addPayloadOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class LogEntryObjectBuilder extends fb.ObjectBuilder {
  final LogEventType? _eventType;
  final int? _contextId;
  final LogLevel? _level;
  final int? _timestamp;
  final String? _source;
  final String? _service;
  final List<int>? _payload;

  LogEntryObjectBuilder({
    LogEventType? eventType,
    int? contextId,
    LogLevel? level,
    int? timestamp,
    String? source,
    String? service,
    List<int>? payload,
  })
      : _eventType = eventType,
        _contextId = contextId,
        _level = level,
        _timestamp = timestamp,
        _source = source,
        _service = service,
        _payload = payload;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? sourceOffset = _source == null ? null
        : fbBuilder.writeString(_source!);
    final int? serviceOffset = _service == null ? null
        : fbBuilder.writeString(_service!);
    final int? payloadOffset = _payload == null ? null
        : fbBuilder.writeListUint8(_payload!);
    fbBuilder.startTable(7);
    fbBuilder.addUint8(0, _eventType?.value);
    fbBuilder.addUint64(1, _contextId);
    fbBuilder.addUint8(2, _level?.value);
    fbBuilder.addUint64(3, _timestamp);
    fbBuilder.addOffset(4, sourceOffset);
    fbBuilder.addOffset(5, serviceOffset);
    fbBuilder.addOffset(6, payloadOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class LogData {
  LogData._(this._bc, this._bcOffset);
  factory LogData(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<LogData> reader = _LogDataReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<LogEntry>? get logs => const fb.ListReader<LogEntry>(LogEntry.reader).vTableGetNullable(_bc, _bcOffset, 4);

  @override
  String toString() {
    return 'LogData{logs: ${logs}}';
  }

  LogDataT unpack() => LogDataT(
      logs: logs?.map((e) => e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, LogDataT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class LogDataT implements fb.Packable {
  List<LogEntryT>? logs;

  LogDataT({
      this.logs});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? logsOffset = logs == null ? null
        : fbBuilder.writeList(logs!.map((b) => b.pack(fbBuilder)).toList());
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, logsOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'LogDataT{logs: ${logs}}';
  }
}

class _LogDataReader extends fb.TableReader<LogData> {
  const _LogDataReader();

  @override
  LogData createObject(fb.BufferContext bc, int offset) => 
    LogData._(bc, offset);
}

class LogDataBuilder {
  LogDataBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addLogsOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class LogDataObjectBuilder extends fb.ObjectBuilder {
  final List<LogEntryObjectBuilder>? _logs;

  LogDataObjectBuilder({
    List<LogEntryObjectBuilder>? logs,
  })
      : _logs = logs;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? logsOffset = _logs == null ? null
        : fbBuilder.writeList(_logs!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, logsOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
